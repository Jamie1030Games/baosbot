"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = require("node:fs");
class db {
    path;
    InitFilePath(path) {
        if (!(0, node_fs_1.existsSync)(path)) {
            (0, node_fs_1.mkdirSync)(path);
        }
        ;
        this.path = path;
    }
    ;
    getFilePath(giveawayId) {
        return `${this.path}/${giveawayId}.json`;
    }
    readGiveawayFile(giveawayId) {
        const filePath = this.getFilePath(giveawayId);
        try {
            const data = (0, node_fs_1.readFileSync)(filePath, 'utf-8');
            return JSON.parse(data);
        }
        catch (error) {
            return null;
        }
    }
    writeGiveawayFile(giveawayId, data) {
        const filePath = this.getFilePath(giveawayId);
        (0, node_fs_1.writeFileSync)(filePath, JSON.stringify(data, null, 2), 'utf-8');
    }
    AddEntries(giveawayId, user) {
        const giveaway = this.readGiveawayFile(giveawayId);
        if (giveaway) {
            giveaway.entries.push(user);
            this.writeGiveawayFile(giveawayId, giveaway);
        }
    }
    RemoveEntries(giveawayId, userId) {
        const giveaway = this.readGiveawayFile(giveawayId);
        if (giveaway) {
            giveaway.entries = giveaway.entries.filter((entry) => entry !== userId);
            this.writeGiveawayFile(giveawayId, giveaway);
            return giveaway.entries;
        }
        return [];
    }
    GetGiveawayData(giveawayId) {
        const giveaway = this.readGiveawayFile(giveawayId);
        return giveaway ? giveaway : undefined;
    }
    Create(giveaway, giveawayId) {
        this.writeGiveawayFile(giveawayId, giveaway);
    }
    SetEnded(giveawayId, state) {
        const giveaway = this.readGiveawayFile(giveawayId);
        giveaway.ended = state;
        this.writeGiveawayFile(giveawayId, giveaway);
        return 'OK';
    }
    SetWinners(giveawayId, winners) {
        const giveaway = this.readGiveawayFile(giveawayId);
        giveaway.winners = winners;
        this.writeGiveawayFile(giveawayId, giveaway);
        return 'OK';
    }
    GetAllGiveawaysData() {
        const giveawayFiles = (0, node_fs_1.readdirSync)(this.path);
        const allGiveaways = [];
        giveawayFiles.forEach((file) => {
            const giveawayId = file.replace('.json', '');
            const giveawayData = this.readGiveawayFile(giveawayId);
            if (giveawayData) {
                allGiveaways.push({ giveawayId, giveawayData });
            }
        });
        return allGiveaways;
    }
    DeleteGiveaway(giveawayId) {
        const filePath = this.getFilePath(giveawayId);
        try {
            (0, node_fs_1.unlinkSync)(filePath);
            console.log(`Giveaway ${giveawayId} deleted successfully.`);
        }
        catch (error) {
            console.error(`Error deleting giveaway ${giveawayId}: ${error}`);
        }
    }
    AvoidDoubleEntries(giveawayId) {
        const giveaway = this.readGiveawayFile(giveawayId);
        const uniqueEntries = Array.from(new Set(giveaway.entries));
        giveaway.entries = uniqueEntries;
        this.writeGiveawayFile(giveawayId, giveaway);
    }
}
;
exports.default = new db();
