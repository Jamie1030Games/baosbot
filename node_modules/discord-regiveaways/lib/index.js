"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GiveawayManager = void 0;
const pwss_1 = require("pwss");
const date = require("date-and-time");
const db_js_1 = require("./db.js");
const deepmerge_ts_1 = require("deepmerge-ts");
;
class GiveawayManager {
    client;
    options;
    constructor(client, options) {
        if (!client.options) {
            throw new Error(`Client is a required option. (val=${client})`);
        }
        this.options = (0, deepmerge_ts_1.deepmerge)({
            storage: './giveaways',
            config: {
                botsCanWin: false,
                embedColor: '#9a5af2',
                embedColorEnd: '#2f3136',
                reaction: '🎉',
                botName: "Giveaway Bot",
                forceUpdateEvery: 3600,
                endedGiveawaysLifetime: 345_600_000,
            },
        }, options || {});
        db_js_1.default.InitFilePath(this.options.storage);
        client.on('interactionCreate', interaction => {
            if (interaction.isButton() && interaction.customId === "confirm-entry-giveaway") {
                this.addEntries(interaction);
            }
            ;
        });
        this.refresh(client);
        setInterval(() => {
            this.refresh(client);
        }, this.options.config.forceUpdateEvery);
    }
    create(channel, data) {
        return new Promise(async (resolve, reject) => {
            try {
                let confirm = new pwss_1.ButtonBuilder()
                    .setCustomId('confirm-entry-giveaway')
                    .setEmoji(this.options.config.reaction)
                    .setStyle(pwss_1.ButtonStyle.Primary);
                let gw = new pwss_1.EmbedBuilder()
                    .setColor(this.options.config.embedColor)
                    .setTitle(data.prize)
                    .setDescription(`Ends: ${(0, pwss_1.time)((date.addMilliseconds(new Date(), data.duration, true)), 'R')} (${(0, pwss_1.time)((date.addMilliseconds(new Date(), data.duration, true)), 'D')})\nHosted by: <@${data.hostedBy}>\nEntries: **0**\nWinners: **${data.winnerCount}**`)
                    .setTimestamp((date.addMilliseconds(new Date(), data.duration, true)))
                    .setFooter({ text: this.options.config.botName })
                    .setImage(data.embedImageURL);
                let response = await channel.send({
                    embeds: [gw],
                    components: [
                        new pwss_1.ActionRowBuilder()
                            .addComponents(confirm)
                    ]
                });
                db_js_1.default.Create({
                    channelId: response.channelId,
                    guildId: response.guildId,
                    winnerCount: data.winnerCount,
                    prize: data.prize,
                    hostedBy: data.hostedBy,
                    expireIn: date.addMilliseconds(new Date(), data.duration, true),
                    ended: false,
                    entries: [],
                    winners: [],
                    isValid: true,
                    embedImageURL: data.embedImageURL
                }, response.id);
                resolve(response);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    async addEntries(interaction) {
        let members = db_js_1.default.GetGiveawayData(interaction.message.id).entries;
        if (members.includes(interaction.user.id)) {
            await this.removeEntries(interaction);
            return;
        }
        else {
            await interaction.deferUpdate();
            let regex = /Entries: \*\*\d+\*\*/;
            let embedsToEdit = pwss_1.EmbedBuilder.from(interaction.message.embeds[0])
                .setDescription(interaction.message.embeds[0]?.description
                .replace(regex, `Entries: **${members.length + 1}**`));
            await interaction.message.edit({ embeds: [embedsToEdit] });
            db_js_1.default.AddEntries(interaction.message.id, interaction.user.id);
            return;
        }
        ;
    }
    ;
    async removeEntries(interaction) {
        await interaction.reply({
            content: `${interaction.user} are you sure to leave this giveaways ?`,
            components: [
                new pwss_1.ActionRowBuilder()
                    .addComponents(new pwss_1.ButtonBuilder()
                    .setCustomId("giveaway-leave")
                    .setStyle(pwss_1.ButtonStyle.Danger)
                    .setLabel("Leave Giveaway"))
            ],
            ephemeral: true
        });
        let collector = interaction.channel.createMessageComponentCollector({
            time: 30_000,
            filter: (i) => interaction.user.id === i.user.id
        });
        collector.on('collect', async (i) => {
            if (i.customId === 'giveaway-leave') {
                let now_members = db_js_1.default.RemoveEntries(interaction.message.id, interaction.user.id);
                let regex = /Entries: \*\*\d+\*\*/;
                let embedsToEdit = pwss_1.EmbedBuilder.from(interaction.message.embeds[0])
                    .setDescription(interaction.message.embeds[0]?.description
                    .replace(regex, `Entries: **${now_members.length}**`));
                await interaction.message.edit({ embeds: [embedsToEdit] });
                await interaction.editReply({ components: [], content: `<@${interaction.user.id}>, you have leave this giveaways !` });
                return;
            }
            ;
        });
    }
    isValid(giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                let fetch = db_js_1.default.GetGiveawayData(giveawayId);
                if (fetch) {
                    resolve(true);
                }
                else {
                    resolve(false);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    isEnded(giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                let fetch = db_js_1.default.GetGiveawayData(giveawayId);
                if (fetch?.ended) {
                    resolve(true);
                }
                else {
                    resolve(false);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    end(client, giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                let giveawayData = db_js_1.default.GetGiveawayData(giveawayId);
                if (giveawayData.isValid && !giveawayData.ended) {
                    db_js_1.default.SetEnded(giveawayId, "End()");
                    this.finish(client, giveawayId, giveawayData.guildId, giveawayData.channelId);
                    resolve();
                }
                else {
                    reject(new Error("Invalid Giveaway"));
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    async finish(client, giveawayId, guildId, channelId) {
        let fetch = db_js_1.default.GetGiveawayData(giveawayId);
        if (!fetch.ended || fetch.ended === 'End()') {
            let guild = await client.guilds.fetch(guildId).catch(async () => {
                db_js_1.default.DeleteGiveaway(giveawayId);
            });
            if (!guild)
                return;
            let channel = await guild.channels.fetch(channelId);
            let message = await channel.messages.fetch(giveawayId).catch(async () => {
                db_js_1.default.DeleteGiveaway(giveawayId);
                return;
            });
            let winner = this.selectWinners({ entries: fetch.entries, winners: fetch.winners }, fetch.winnerCount);
            let winners = winner ? winner.map((winner) => `<@${winner}>`) : 'None';
            let Finnish = new pwss_1.ButtonBuilder()
                .setLabel("Giveaway Finished")
                .setURL('https://media.tenor.com/uO4u0ib3oK0AAAAC/done-and-done-spongebob.gif')
                .setStyle(pwss_1.ButtonStyle.Link);
            let embeds = new pwss_1.EmbedBuilder()
                .setColor(this.options.config.embedColorEnd)
                .setTitle(fetch.prize)
                .setImage(fetch.embedImageURL)
                .setDescription(`Ended: ${(0, pwss_1.time)(new Date(fetch.expireIn), 'R')} (${(0, pwss_1.time)(new Date(fetch.expireIn), 'D')})\nHosted by: <@${fetch.hostedBy}>\nEntries **${fetch.entries.length}**\nWinners: ${winners}`)
                .setTimestamp();
            await message?.edit({
                embeds: [embeds], components: [
                    new pwss_1.ActionRowBuilder()
                        .addComponents(Finnish)
                ]
            });
            if (winners !== 'None') {
                await message?.reply({
                    content: `Congratulations ${winners}! You won the **${fetch.prize}**!`
                });
            }
            else {
                await message?.reply({
                    content: "No valid entrants, so a winner could not be determined!"
                });
            }
            ;
            db_js_1.default.SetEnded(giveawayId, true);
            db_js_1.default.SetWinners(giveawayId, winner || 'None');
        }
        ;
        return;
    }
    ;
    selectWinners(fetch, number) {
        if (fetch.entries.length === 0) {
            return undefined;
        }
        ;
        let areWinnersInPreviousWinners = (currentWinners) => {
            return currentWinners.some(winner => fetch.winners.includes(winner));
        };
        let winners = [];
        do {
            winners = [];
            let availableMembers = [...fetch.entries];
            if (winners.length === 0 || areWinnersInPreviousWinners(winners)) {
                winners = [];
            }
            ;
            for (let i = 0; i < number; i++) {
                if (availableMembers.length === 0) {
                    break;
                }
                let randomIndex = Math.floor(Math.random() * availableMembers.length);
                let winnerID = availableMembers.splice(randomIndex, 1)[0];
                winners.push(winnerID);
            }
        } while (winners.length === 0);
        return winners.length > 0 ? winners : undefined;
    }
    ;
    reroll(client, giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                let fetch = await db_js_1.default.GetGiveawayData(giveawayId);
                let guild = await client.guilds.fetch(fetch.guildId);
                let channel = await guild.channels.fetch(fetch.channelId);
                let message = await channel.messages.fetch(giveawayId).catch(async () => {
                    await db_js_1.default.DeleteGiveaway(giveawayId);
                    resolve();
                    return;
                });
                let winner = this.selectWinners({ entries: fetch.entries, winners: fetch.winners }, fetch.winnerCount);
                let winners = winner ? winner.map((winner) => `<@${winner}>`) : [];
                let embeds = new pwss_1.EmbedBuilder()
                    .setColor(this.options.config.embedColorEnd)
                    .setTitle(fetch.prize)
                    .setImage(fetch.embedImageURL)
                    .setDescription(`Ended: ${(0, pwss_1.time)(new Date(fetch.expireIn), 'R')} (${(0, pwss_1.time)(new Date(fetch.expireIn), 'D')})\nHosted by: <@${fetch.hostedBy}>\nEntries **${fetch.entries.length}**\nWinners: ${winners}`)
                    .setTimestamp()
                    .setFooter({ text: this.options.config.botName });
                await message?.edit({
                    embeds: [embeds]
                });
                if (winner && winner[0] !== 'None') {
                    await message?.reply({
                        content: `Congratulations ${winners}! You won the **${fetch.prize}**!`
                    });
                }
                else {
                    await message?.reply({
                        content: "No valid entrants, so a winner could not be determined!"
                    });
                }
                await db_js_1.default.SetWinners(giveawayId, winner || 'None');
                resolve();
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    async listEntries(interaction, giveawayId) {
        let fetch = db_js_1.default.GetGiveawayData(giveawayId);
        if (interaction.guildId === fetch.guildId) {
            var char = fetch.entries;
            if (char.length == 0) {
                await interaction.editReply({ content: "There is no entry into this competition." });
                return;
            }
            ;
            let currentPage = 0;
            let usersPerPage = 10;
            let pages = [];
            for (let i = 0; i < char.length; i += usersPerPage) {
                let pageUsers = char.slice(i, i + usersPerPage);
                let pageContent = pageUsers.map((userId) => `<@${userId}>`).join('\n');
                pages.push({
                    title: `Giveaway's Entries List | Page ${i / usersPerPage + 1}`,
                    description: pageContent,
                });
            }
            ;
            let createEmbed = () => {
                return new pwss_1.EmbedBuilder()
                    .setColor(this.options.config.embedColor)
                    .setTitle(pages[currentPage].title)
                    .setDescription(pages[currentPage].description)
                    .setFooter({ text: `${this.options.config.botName} | Page ${currentPage + 1}/${pages.length}`, iconURL: interaction.client.user?.displayAvatarURL() })
                    .setTimestamp();
            };
            let row = new pwss_1.ActionRowBuilder().addComponents(new pwss_1.ButtonBuilder()
                .setCustomId('previousPage')
                .setLabel('⬅️')
                .setStyle(pwss_1.ButtonStyle.Secondary), new pwss_1.ButtonBuilder()
                .setCustomId('nextPage')
                .setLabel('➡️')
                .setStyle(pwss_1.ButtonStyle.Secondary));
            let messageEmbed = await interaction.editReply({
                embeds: [createEmbed()], components: [row]
            });
            let collector = messageEmbed.createMessageComponentCollector({
                filter: (i) => {
                    i.deferUpdate();
                    return interaction.user.id === i.user.id;
                }, time: 60000
            });
            collector.on('collect', (interaction) => {
                if (interaction.customId === 'previousPage') {
                    currentPage = (currentPage - 1 + pages.length) % pages.length;
                }
                else if (interaction.customId === 'nextPage') {
                    currentPage = (currentPage + 1) % pages.length;
                }
                messageEmbed.edit({ embeds: [createEmbed()] });
            });
            collector.on('end', () => {
                row.components.forEach((component) => {
                    if (component instanceof pwss_1.ButtonBuilder) {
                        component.setDisabled(true);
                    }
                });
                messageEmbed.edit({ components: [row] });
            });
        }
        ;
    }
    ;
    refresh(client) {
        let drop_all_db = db_js_1.default.GetAllGiveawaysData();
        for (let giveawayId in drop_all_db) {
            let now = new Date().getTime();
            let gwExp = new Date(drop_all_db[giveawayId].giveawayData.expireIn).getTime();
            let cooldownTime = now - gwExp;
            db_js_1.default.AvoidDoubleEntries(drop_all_db[giveawayId].giveawayId);
            if (now >= gwExp) {
                this.finish(client, drop_all_db[giveawayId].giveawayId, drop_all_db[giveawayId].giveawayData.guildId, drop_all_db[giveawayId].giveawayData.channelId);
            }
            ;
            if (cooldownTime >= this.options.config.endedGiveawaysLifetime) {
                db_js_1.default.DeleteGiveaway(drop_all_db[giveawayId].giveawayId);
            }
            ;
        }
    }
    ;
    getGiveawayData(giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                let fetch = await db_js_1.default.GetGiveawayData(giveawayId);
                if (fetch) {
                    resolve(fetch);
                }
                else {
                    reject(new Error("Giveaway non trouvé"));
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
    getAllGiveawayData() {
        return db_js_1.default.GetAllGiveawaysData();
    }
    delete(giveawayId) {
        return new Promise(async (resolve, reject) => {
            try {
                if (await this.isValid(giveawayId)) {
                    await db_js_1.default.DeleteGiveaway(giveawayId);
                    resolve(true);
                }
                else {
                    reject(new Error("Giveaway non valide"));
                }
            }
            catch (error) {
                reject(error);
            }
        });
    }
    ;
}
exports.GiveawayManager = GiveawayManager;
